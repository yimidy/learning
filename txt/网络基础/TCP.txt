TCP/IP协议分层：

osi七层网络参考模型： 应用层-->表示层-->会话层-->传输层-->网络层-->数据链路层-->物理层
tcp/ip四层网络参考模型： 应用层-->传输层-->网络层-->网络接口层
	对应协议有：	HTTP，HTTPS，FTP，SMTP等--->TCP,UDP--->IP--->Ethernet（以太网协议）
TCP/IP由上到下层层包装

网络接口层：以太网协议，规定电子信号之间如何组成数据包，解决子网内部点对点通信（总线型，环形，星型，树状型）。接受IP数据报并通过网络发送，或从网络上接受物理帧，抽出IP数据报，交给IP层。

网络层：负责计算机之间的通信。即连接多个局域网。IP协议定义一套自己的规则，称为IP地址。每个计算机必须有一个IP地址才能介入因特网，两个局域网之间通信通过IP地址发送消息。

传输层：提供应用程序见的通信。格式化信息流，提供可靠传输。TCP（传输控制协议）和UDP（用户数据报协议）

应用层：向用户提供一组常用的应用程序，如远程登录Telent使用Telent协议提供在网络其他主机上注册的接口。文件传输访问FTP使用Ftp协议提供网络内机器间的文件拷贝功能。



以太网协议解决了局域网的点对点通信。
IP 协议可以连接多个局域网。
TCP 协议的作用是，保证数据通信的完整性和可靠性，防止丢包。


IP地址？？？

-----------------------------------------------------------------------------------------------

TCP协议

TCP用于应用程序之间通信。

当应用程序希望通过TCP与另一个应用程序通信时，它会发送一个通信请求。在双方“握手”之后，TCP将在两个应用程序之间建立一个双全工的通信。

双全工通信：通信双方可以同时接受和发送信息的信息交互方式。
---------------------------------------------------------------------------------------------
TCP数据包的大小

IP数据包包含在以太网数据包，TCP数据包包含在IP数据包中
	以太网HEAD + 以太网_Data
		     以太网_Data	 = IP_HEAD + IP_Data
                                             IP_Data = TCP_HEAD + TCP_Data/UDP_Data
								  TCP_Data/UDP_Data = 应用层数据包Data
以太网数据包大小固定，最初1518B，现在1522B。其中，1500B为负载，22B为头信息。
IP数据包为1500B。其中，1480B为负载，20B为头信息（最少）。
TCP数据包为1480B。其中，20B为头信息（最少），故最大负载1460B。由于TCP和IP协议可能有额外头信息，故TCP实际负载为1400B。

因此，一条1500字节的信息需要两个 TCP 数据包。HTTP/2 协议的一大改进， 就是压缩 HTTP 协议的头信息，使得一个 HTTP 请求可以放在一个 TCP 数据包里面，而不是分成多个，这样就提高了速度。
----------------------------------------------------------------------------------------------
TCP数据包编码

一个包1400B，若一次性发送大量数据，则需要多个包的发送。

发送时，TCP协议为每个包编码，以便接收方按顺序还原。万一丢包，可以知道是哪个包丢了。

数据包的内容有：该包编号，负载长度（当前编号+负载长度=下一个包编号）
-------------------------------------------------------------------------------------------------
TCP数据包组装
收到TCP数据包后，组装由操作系统完成。操作系统不会处理TCP数据包中数据，故组装好之后将其交给应用程序。（TCP数据包里面有一个端口参数，就是用来指定转交给监听该端口的应用程序）

TCP并没有提供任何机制表示原文大小，这应由应用层协议来规定。比如HTTP协议有一个头信息Content-Length，表示信息体大小。

应用程序收到组装好的原始数据，，以浏览器为例，就会根据HTTP协议的Content-Length字段正确读出一段段数据。这也意味着，一次TCP通信可以包含多个HTTP通信。
---------------------------------------------------------------------------------------------------
TCP数据包传输

慢启动：服务器发送数据包，当然越快越好，但发太快容易丢失包的可能性也大。（带宽小、路由器过热等）。怎样才能达到一个理想的状态呢？慢启动机制。开始时，发送较慢，根据丢包情况，调整速率；不丢包加快发送，丢包减缓。
一般是一次发10个数据包（即发送窗口大小为10），停下来，等待对方确认；默认接收方收到2个数据包，就要发回一个确认信息。
确认信息怎么查看，这里用到ACK。ACK携带两个信息，期待要传输的下一个数据包编号和接收方的接受窗口的剩余容量

TCP传输协议中6位标志域：
URG，紧急标志。指向后面是优先数据的字节。为1时启动。
ACK，确认标志。多数情况下是位置信息。ACK=1时确认号ack才有效。
PSH，推标志。标志位置时，接收端不再将数据进入队列处理，而是尽可能将数据转由应用处理。
RST，复位标志。复位相应的TCP连接。
SYN，同步标志。表示同步序列编号栏有效。仅在三次握手建立TCP连接有效。表示一个连接请求或连接接受报文。
FIN，结束标志。一端发送完成，向另一端发送完成标志。
--------------------------------------------------------------------------------------------------------------
TCP数据包丢包处理

TCP协议可以保证数据通信的完整性和可靠性，防止丢包。
它是怎么做到的呢？
前面提到，每一个数据包都带有下一个数据包的编号，存储在ACK里。如果下一个数据包没有收到，那么ACK的编号就不会有改变。
举例，现在收到了4包，ack为1；5包没有收到，一会6包、7包也相继收到，此时ack还是1；若发送方收到3个连续的重复ACK，或者超时还没有收到，就会确认丢包，从而再次发送丢包的数据请求。

TCP拥塞机制：在某段时间内，若对网络中某资源的需求超过了该资源所提供的可用部分，网络性能变坏，这种情况叫做拥塞。

接收窗口：接收端根据目前接收缓存大小所许诺的新窗口值，是来自接收端的流量控制。
自己理解：每次运行请求的最大数。

拥塞窗口：是发送端根据自己估计的网络拥塞程度而设置的窗口值。
------------------------------------------------------------------------------------------------------------
三次握手
client向server发起请求连接，选择序号seq=x，SYN=1
server向clent确认接收到请求，SYN=1，ACK=1，ack=x+1，seq=y
client向server给出确认，ACK=1，ack=y+1，client确认连接建立；server收到ACK=1时，也确认建立连接。


四次挥手
client向server发送FIN=1，seq=x，表示自己数据发送完毕，等待server确认
server向client发送ACK=1，ack=x+1，seq=y；client向server的连接释放，此时TCP连接处于半关闭状态，server发送数据，client还是要接收
server向client发送FIN=1，ACK=1，seq=z，ack=x+1，表示自己数据也发送完毕，等待client确认
client向server发送ACK=1，ack=z+1，确认可以断开连接并在2个MSL（最大报文生存时间）后断开连接


SYN攻击
在三次握手过程中，server向client发送ACK后，处于半连接。此时server处于SYN_RCVD状态，再接收到client的ACK后转为ESTABLISHED状态。SYN攻击就是client在短时间内伪造大量不存在的IP地址，冰箱server不断发送SYN包，server恢复确认包，并等待client的确认，由于原地址不存在，因此，server需要不断重发直到超时，这些伪造的SYN包将占用连接队列，导致正常SYN包因队列满而被丢弃，从而引起网络阻塞甚至系统瘫痪。SYN攻击就是典型的DDOS攻击。
检测SYN攻击方式：当server端上有大量处于半连接状态且源IP地址是随机的，就可以断定是遭到SYN攻击了。#netstat -nap | grep SYN_RECV

两次握手可以吗？
不可以，为避免已失效的连接请求（client发送的一个连接请求报文段在网络节点长时间留置，以致于在该连接已经释放后改请求才到达server端，此时，视该请求无效）发送到服务器上，服务器并不知道这是失效请求，就确认收到请求，建立连接，若是两次握手，这说明该连接已经建立成功，但此时client并没有要发出请求，并不会理财server，就白白浪费了资源。所以client的再次确认是非常有必要的。

为什么是三次握手，四次挥手？
在连接中，server端的SYN和ACK是一次性发送的；断开连接过程中，server向client发送ACK和FIN是分两次的，因为第一次client请求断开时server的数据可能还没发送完毕，所以他想client只发送了ACK确认收到它的断开请求，但再等一会我还没发完，等server也发完了，在向client发送FIN，表示发完，client收到后就可以确认断开了。

问什么第四次挥手有2个MSL的延迟？
原因有二：

一、保证TCP协议的全双工连接能够可靠关闭

二、保证这次连接的重复数据段从网络中消失


先说第一点，如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。
再说第二点，如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。


TCP和UDP的区别？
UDP是无连接的，即发送数据不需要建立连接；TCP是面向连接的传输层协议
UDP传输不可靠，TCP是可靠交付服务（全双工通信）
UDP是面向报文的，TCP是面向字节流
UDP没有拥塞控制，因此网络拥塞不会造成主机发送速率低，允许拥塞造成的丢失，不允许大时延；TCP有拥塞控制、流量控制、重传机制、保活机制
UDP支持一对一，一对多，多对一，多对多；TCP是点对点的，只能一对一
UDP首部8字节，开销少；TCP首部20字节，开销大
UDP消息在传输过程中无序，TCP有序

TCP保活机制：
TCP的KeepAlive机制（此机制并不是TCP协议规范中的内容，由操作系统去实现），KeepAlive机制开启后，在一定时间内（一般时间为7200s，参数tcp_keepalive_time）在链路上没有数据传送的情况下，TCP层将发送相应的KeepAlive探针以确定连接可用性，探测失败后重试10（参数tcp_keepalive_probes）次，每次间隔时间75s（参数tcp_keepalive_intvl），所有探测失败后，才认为当前连接已经不可用。才会断开连接，进行重连或者链接另一台服务器。这些参数是机器级别，可以调整。




TCP重传机制
数据包丢包处理
超时重传


TCP拥塞控制

TCP流量控制




