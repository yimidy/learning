渲染机制：

1. 解析html文档，生成DOM树和Style树
2. 两者进行合并，生成render树
3. 布局，确定元素位置
4. 绘制，在浏览器上显示

（真正执行并不是严格按照这个顺序执行的，css渲染与加载DOM是同时进行的，这也是为什么文档还没加载完就已经出现部分页面。）



HTML页面加载和解析流程 

1. 用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件； 
2. 浏览器开始载入html代码，发现＜head＞标签内有一个＜link＞标签引用外部CSS文件； 
3. 浏览器又发出CSS文件的请求，服务器返回这个CSS文件； 
4. 浏览器继续载入html中＜body＞部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了； 
5. 浏览器在代码中发现一个＜img＞标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码； 
6. 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码； 
7. 浏览器发现了一个包含一行Javascript代码的＜script＞标签，赶快运行它； 
8. Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个＜div＞ （style.display=”none”）。突然少了这么一个元素，浏览器不得不重新渲染这部分代码； 
9. 终于等到了＜/html＞的到来，浏览器泪流满面…… 
10. 等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径； 
11. 浏览器召集了在座的各位＜div＞＜span＞＜ul＞＜li＞们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。




css样式文件的加载和解析流程
    
    在遇到<style>标签时加载css样式文件，一般写在head里；css的渲染与DOM的加载大多数情况下是并行的（css文件下载ing，继续解析文档，下载完毕后解析并直接渲染节点，呈现页面）

    css解析由右向左，因为这样会提高渲染速度，从底层向上，任何一个标签都会有一个父标签（html除外），可以一直向上查找；而从上向下，一个父标签可能有多个子标签，不利于遍历。

    引入方式：行内样式，内部嵌入样式，外部引入样式

    性质：继承性，优先级（权重），层叠性





js脚本文件的加载与解析流程

    js是解释型语言，不需要编译，有专门的解释器---js引擎，存在于浏览器端。

    遇到<script>标签，停止浏览器的渲染和下载其他文件，若是内部脚本，加载执行；若是外部引入脚本，下载，并且下载完成后立即执行；
	
    所以一般吧js脚本文件放在body里而不是head里，因为这样会影响网页的加载和渲染速度，并且有可能会报错（js若是执行里面的某个为加载的dom节点，浏览器还找不到就会报错）

    一般将js脚本文件放在body里加载；或者放在head里时设置无阻塞defer（异步）；或者设置动态加载，在网页所以资源下载完毕，动态添加script标签的src属性，此时才下载脚本；尽量合并脚本文件。





外部资源（图片、视频、音频等）

    当文档解析到图片标签时，向服务器发送请求，但浏览器并不会等图片下载完毕，而是会继续渲染后面代码，服务器返回图片时再次布局。
	
    浏览器会等css加载完成在加载图片，因为不知道图片的样式会如何（即css会阻塞图片的加载）
    脚本不会阻塞图片的加载

    一般情况下浏览器会在加载完css，js后下载外部资源





