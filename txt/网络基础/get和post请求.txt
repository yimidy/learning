1） GET用于取回数据，POST用于获取数据（但没什么用，个人认为）

2） GET提交参数追加在url后面，POST参数可以通过http body提交

	有误理解：http协议并没有明确规定GET/POST要用什么方式传输数据。GET也可以用http body的方式；POST也可以在url后拼参。之所以出现这种说法是因为浏览器的设计和服务器的设计，浏览器不支持GET+httpbody

3） GET和POST长度的限制问题

	有误理解：HTTP协议对url长度没有任何限制，同样，对 http body也没有限制；造成这种观点还是浏览器和服务器配置的影响。太长的url没什么用，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。太大的body对传输性能也有影响

	IE 和 Safari 浏览器 限制 2k，Opera 限制4k，Firefox 限制 8k（非常老的版本 256byte），如果超出了最大长度，大部分的服务器直接截断，也有一些服务器会报414错误。

4） GET提交可以被缓存，POST不会

	关于http response的缓存，GET是幂等的，POST不幂等

	幂等是指同一个请求方法执行多次和仅执行一次的效果完全相同
	
	所以说，GET请求的重复发送效果与上一次完全相同，有类似缓存的效果；POST请求的重复发送效果可能会带来意想不到的结果（但也只是再次请求，大多数情况与上次都是一样的）。这也是浏览器在后退/刷新时遇到POST会给用户提示的原因

	举例：比如在微博这个场景里，GET的语义会被用在「看看我的Timeline上最新的20条微博」这样的场景，而POST的语义会被用在「发微博、评论、点赞」这样的场景中。

5） GET提交信息明文显示在url上，不安全；POST提交信息不会显示在url上
	注意：这句话本意没有任何问题，但关于GET和POST的安全性问题，他两区别不大。
	GET通过url方式，明文传输；其请求会主动保存在浏览器历史记录里，还可能会保存在Web日志中。
	POST是通过header请求，可以再开发者工具或者抓包可到，同样也是明文；POST请求参数不会保存到浏览器记录中

6） GET请求产生一个数据包，POST请求产生两个数据包

	GET请求，浏览器会把header和data一起发送出去，服务器响应200（返回数据）
	
	POST请求，浏览器会先发header，服务器响应100 continue，浏览器再次发送data，服务器响应200（返回数据）

	因为POST需要2步，时间上消耗多一点，看起来GET更高效，但其实，网络环境好的情况下，发一次包的时间与发两次包的时间查基本可以无视；而在网络环境差的情况下，两次包的TCP在验证数据包的完整性上好很多。而且firefox的POST就只发一次。所以说，用GET来替代POST来优化网站这是不严谨的。

7）post能发送更多的数据类型（get只能发送ASCII字符） 

 
post不能进行管道化传输 
http权威指南中是这样说的：http的一次会话需要先建立tcp连接（大部分是tcp，但是其他安全协议也是可以的），然后才能通信，如果 每次连接都只进行一次http会话，那这个连接过程占的比例太大了！于是出现了持久连接：在http/1.0+中是connection首部中添加keep-alive值，在http/1.1中是在connection首部中添加persistent值，当然两者不仅仅是命名上的差别，http/1.1中，持久连接是默认的，除非显示在connection中添加close，否则持久连接不会关闭，而http/1.0+中则恰好相反，除非显示在connection首部中添加keep-alive，否则在接收数据包后连接就断开了。 
出现了持久连接还不够，在http/1.1中，还有一种称为管道通信的方式进行速度优化：把需要发送到服务器上的所有请求放到输出队列中，在第一个请求发送出去后，不等到收到服务器的应答，第二个请求紧接着就发送出去，但是这样的方式有一个问题：不安全，如果一个管道中有10个连接，在发送出9个后，突然服务器告诉你，连接关闭了，此时客户端即使收到了前9个请求的答复，也会将这9个请求的内容清空，也就是说，白忙活了……此时，客户端的这9个请求需要重新发送。这对于幂等请求还好（比如get，多发送几次都没关系，每次都是相同的结果），如果是post这样的非幂等请求（比如支付的时候，多发送几次就惨了），肯定是行不通的。 
所以，post请求不能通过管道的方式进行通信！很有可能，post请求需要重新建立连接，这个过程不跟完全没优化的时候一样了么？所以，在可以使用get请求通信的时候，不要使用post请求，这样用户体验会更好，当然，如果有安全性要求的话，post会更好。管道化传输在浏览器端的实现还需考证，貌似默认情况下大部分浏览器（除了opera）是不进行管道化传输的，除非手动开启！ 




Body对象
	1. 不管是请求还是响应都能够包含Body对象，Body也可是是以下任意类型的实例

		1) ArrayBuffer
		用来表示通用的，固定长度的原始二进制数据缓存区。不能直接操作,通过类型数组对象或DataView对象来操作，会将缓存区数据表示为特定格式，并通过这些格式来读写缓冲区内容。
		new ArrayBuffer（length）
		参数，length，要创建的ArrayBuffer的大小，单位为字节
		返回值，一个指定大小的ArrayBuffer对象，内容初始化为0

		2) Blob
		用来表示一个不可变。原始数据的类文件对象。
	
		3) File
		File接口基于Blod，继承了Blob的功能并将其扩展使用支持用户系统上的文件。

		4) string

		5) URLSearchParams
		定义一些实用的方法来处理URL的查询字符串

		6) FormData
		XMLHttpRequest Level 2添加了一个新的接口FormData.利用FormData对象,我们可以通过JavaScript用一些键值对来模拟一系列表单控件,我们还可以使用XMLHttpRequest的send()方法来异步的提交这个"表单".比起普通的ajax,使用FormData的最大优点就是我们可以异步上传一个二进制文件.

	2. 方法 (这些方法都被 Request 和Response所实现)以获取body内容. 这些方法都会返回一个被解析后的promise对象和数据.
		1） arrayBuffer()
		2） bloob()
		3） json()
		4)  text()
		5)  formData()
			
